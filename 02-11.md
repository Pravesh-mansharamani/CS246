### Last Class : 
- Virtual Methods, destructors.

### Today :
- Pure virtual methods, Copy/Move with Inheritance.


```c++

class Student{
    public:
        virtual int fees() const;
};

class Coop : public Student{
    public:
        int fees() const override;
}; //Compute coop fees  + coures fees

class Regular : public Student{
    public:
        int fees() const override;
}; // Just regular fees 
```

I'm assuming that every student is either a coop or a regular student. 
So then What should Student::fees() return? No natural choice, Ideally we enfore that all students are either coop or regular. 

<br>

Solution : Make Student::fees() **pure virtual**. 

```cpp

class Student{
    public:
        virtual int fees() const = 0;  // equals 0 means pure virtual
};
```

Pure virtual methods do not require an implementation. Classes that define pure virtual methods cannot have objects instantiated from them.
Student s; // Error - won't compile

<br>

Classes with pure virual methods are called **abstract classes**. Sub-classes of abstract classes are also abstract unless they override all pure virtual methods. 

<br>

If a calss impliments all pure virtual methods from its superclasses then it is concrete, and can be instantiated. Abstract classes are used to organize sublcasses.

```cpp

class Student  { // Abstract class
    public:
        virtual int fees() const = 0;
    
    Protected:
        int numCourses;
};

class Regular : public Student { // Concrete class
    public:
        int fees() const override { return 900 * numCourses; }
};
//Now if we create any student it would be a regular student by default.
```

In UML : Represent pure virtual methods and abstact classes with italics.
For handWriting  : * Name *
eg : 
            * Student *
        * Fees() : int *
          /         \
        Coop        Regular


# Inharitance and Copy/Move

```cpp
class Book {
    string title, author;
    int length;
    public:
        //Define BIG 5
};

class Text : public Book {
    string topic;
    public:
        //use complier provided BIG 5
};

Text t1{"a", "b", 100, "c"};
Text t2{"d", "e", 200, "f"};
t1 = t2; // What happend here? - Uses Text::operator=() and it works fine.

// Works as expected , t1 copies all values from t2.
```
How can we write our own BIG 5 w/ Inheritance?

```cpp

Text::Text(const Text& other) : Book{other}, topic{other.topic} {} // Copy Constructor
//                                  ^^^ This invokes Book's copy constructor
// This is generated by the compiler if we don't define it.

Text::Text(Text&& other) : Book{std::move(other)}, topic{std::move(other.topic)} {} // Move Constructor 
// WHY does Book{other} not work here? - Because we are moving other, not copying it. 
// It would run copy ctor, not move ctor. why? other, although an rvalue reference,
// other itself is an lvalue. Which would invoke copy ctor.

// std::move takes a value and forces it to be treated as an rvalue reference.
// Which allows us to run Book and stirng ctor instead of the copy versions 
// (We say to compiler Bro trust me, I know what I'm doing)

Text& Text::operator=(const Text& other){ // Copy assignment operator
    Book::operator=(other); // calls Books Copy assignment operator to copy title, author and length
    topic = other.topic;
    return *this;
}

Text& Text::operator=(Text&& other){ // Move assignment operator
    Book::operator=(std::move(other));
    topic = std::move(other.topic);
    return *this;
}

```
Now consider : 

```cpp
Text t1{"a", "b", 100, "c"}, t2{"d", "e", 200, "f"};
Book & r1 = t1;
Book & r2 = t2;
r1 = r2; // What happens here?
// r1 and r2 are references to Book. We call operator=() via reference, 
// operator=() is not virtual. Hence, use static type, which is book so we call Book::operator=().

Text t1 {"Algo", "CLRS", 1000, "CS"};
Text t2 {"Shakespeare", "Enlisg prof.", 500, "English"};

Book & r1 = t1;
Book & r2 = t2;
r1 = r2; 
// New t1 contains: Title: Shakespeare, Author: English prof., Length: 500, Topic: CS.
// This is called virtual assignment!
// What if instead we made operator=() virtual? - then we would use dynamic type!

class Book {
    string title, author;
    int length;
    public:
        virtual Book& operator=(const Book& other);
};

class Text : public Book {
    string topic;
    public:
        Text& operator=(const Text& other) override; // override would not work here, because we are not overriding anything.
    //                        ^^^^Cannot take in a const Text&, must be a const Book&.
    //  ^^^ Allowed, we can return subclass ptr or reference types in overrides.
};

// Doing so, the follwing now complies : 
Text t1 {...};
t1 = Book{...}; // This is allowed now, because we are using dynamic type.
t2 = Comic{...};
// both now compile! THIS IS MIXED ASSIGNMENT!
```

If we make operator=() virtual, then we get mixed assignment. If non-virtual, then we get partial assignment. soluation, restructure book hierarchy, use abstract superclass. And use a protected assignment operator.

                *  Abstract Book *
                   /       \     \   
                Regular   Text   Comic

```cpp

class AbstractBook {
    string title, author;
    int length;
    protected:
        AbstractBook& operator=(const AbstractBook& other);
    public:
        AbstarctBook (...) : ... {} 
        virtual ~AbstractBook() = default; // use pure virtual destructor to enforce abstractness.
};

class Regular : public AbstractBook {
    public:
        Regular& operator=(const Regular& other) {
            AbstractBook::operator=(other);
            return *this;
        }
};

/*
How does this fix our problem of mixed assignment?
- Now we can only set Texts to texts, comics to comics, etc.

Partial assignment:*/
Text t1{...}, t2{...}; 
AbstractBook & r1 = t1;
AbstractBook & r2 = t2;
r1 = r2; // Error, AbstatctBook::operator= is protected . Wont compile.



